<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Kubernnetes on Tehami's Blog</title><link>http://t3hami.github.io/tags/kubernnetes/</link><description>Recent content in Kubernnetes on Tehami's Blog</description><image><title>Tehami's Blog</title><url>http://t3hami.github.io/images/avatar.jpg</url><link>http://t3hami.github.io/images/avatar.jpg</link></image><generator>Hugo -- 0.150.0</generator><language>en-us</language><lastBuildDate>Sun, 19 Dec 2021 01:14:26 +0500</lastBuildDate><atom:link href="http://t3hami.github.io/tags/kubernnetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Jenkins On-Demand Agents</title><link>http://t3hami.github.io/tech/post_4/</link><pubDate>Sun, 19 Dec 2021 01:14:26 +0500</pubDate><guid>http://t3hami.github.io/tech/post_4/</guid><description>&lt;h2 id="jenkins"&gt;Jenkins&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Jenkins Architecture" loading="lazy" src="http://t3hami.github.io/images/posts/post_4/jenkins-architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;Jenkins is a server for automation that is free and open source. By automating the software development process, enterprises can save time and money. Jenkins is a tool that manages and controls software delivery processes across the whole lifecycle, including build, document, test, package, stage, deployment, static code analysis, and more.&lt;/p&gt;
&lt;p&gt;A typical Jenkins running in any organization looks like the above diagram. But there are multiple problems with the above architecture.&lt;/p&gt;</description></item><item><title>Understand Autoscaling Applications In Kubernetes Before Next Peak Hours</title><link>http://t3hami.github.io/tech/post_3/</link><pubDate>Tue, 07 Dec 2021 23:20:15 +0500</pubDate><guid>http://t3hami.github.io/tech/post_3/</guid><description>&lt;h2 id="what-is-autoscaling"&gt;What is Autoscaling?&lt;/h2&gt;
&lt;p&gt;Automatic scaling, is a cloud computing strategy that dynamically modifies the amount of computational resources required for an application. Normally measured by the number of active servers based on the load on the farm. For example, the number of servers hosting a web application can automatically increase or decrease based on the number of active users on your site. Because such metrics can fluctuate substantially during the day, and servers are a limited resource that cost money to run even when inactive, there is often an incentive to run “just enough” servers to support the current demand while still being able to handle sudden and large surges in activity. Autoscaling is useful for such situations because it may reduce the number of active servers when activity is low, and it can also increase the number of active servers when activity is high.&lt;/p&gt;</description></item></channel></rss>